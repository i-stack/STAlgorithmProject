# iOS 消息转发流程 探究

> OC方法调用的本质是给对象发送消息:objc_msgSend()，这个流程可以分为三个阶段
> > 消息发送
> > 
> > 动态方法解析
> > 
> > 消息转发

## **消息发送**

* ***函数原型***

```
void objc_msgSend(void /* id self, SEL op, ... */)

其中第一参数是消息接收者，后面是要执行的方法。
```
* ***查找源码***

> 打开runtime源码 -> 搜索objc_msgSend -> 找到objc-msg-arm64.s文件 -> 找到ENTRY _objc_msgSend
> 
> 汇编使用 ENTRY + 函数名字 函数入口
> 
> 使用 END_ENTRY + 函数名字 函数结束

* ***_objc_msgSend***
```
ENTRY _objc_msgSend

	UNWIND _objc_msgSend, NoFrame

	/** 
	 *  nil check and tagged pointer check
	 *
	 *  po与0作比较
	 */ 
	cmp	p0, #0
	
#if SUPPORT_TAGGED_POINTERS
	// less than or equal to)的意思当结果为小于等于的时候跳转执行
	b.le	LNilOrTagged		//  (MSB tagged pointer looks negative)
#else
	// 比较结果是等于（equal to），执行LReturnZero，否则不跳转
	b.eq	LReturnZero
#endif
	// 根据当前对象isa找到所属类
	ldr	p13, [x0]		// p13 = isa
	GetClassFromIsa_p16 p13, 1, x0	// p16 = class
LGetIsaDone:
	// calls imp or objc_msgSend_uncached
	CacheLookup NORMAL, _objc_msgSend, __objc_msgSend_uncached

#if SUPPORT_TAGGED_POINTERS
LNilOrTagged:
	b.eq	LReturnZero		// nil check
	GetTaggedClass
	b	LGetIsaDone
// SUPPORT_TAGGED_POINTERS
#endif

LReturnZero:
	// x0 is already zero
	mov	x1, #0
	movi	d0, #0
	movi	d1, #0
	movi	d2, #0
	movi	d3, #0
	ret
	
END_ENTRY _objc_msgSend
```
> _objc_msgSend 主要做了下面几件事：
> 
> > 1、如果receiver为nil:
> >
> > > 如果receiver是tagged pointer，则跳转到 LNilOrTagged;
> > > 
> > > > LNilOrTagged 检查receiver是否为nil，如果为nil，直接跳转到LReturnZero并返回；
> > > > 
> > > 如果receiver不是tagged pointer，直接跳转到LReturnZero并返回；
> > > >
> > 2、如果receiver不为nil:
> > 
> > > 执行GetTaggedClass后跳转到LGetIsaDone，执行 CacheLookup 从缓存中查找；
> > > 

```mermaid
graph TD
A(_objc_msgSend)-->B1(receiver是否为空)
A(_objc_msgSend)-->B2(333)
A(_objc_msgSend)--->B3(333)
A(_objc_msgSend)->B4(444)

```
