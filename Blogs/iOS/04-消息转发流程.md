# iOS 消息转发流程 探究

> OC方法调用的本质是给对象发送消息:objc_msgSend()，这个流程可以分为三个阶段
> > 消息发送
> > 
> > 动态方法解析
> > 
> > 消息转发

## **消息发送**

* ***函数原型***

```
void objc_msgSend(void /* id self, SEL op, ... */)

其中第一参数是消息接收者，后面是要执行的方法。
```
* ***查找源码***

> 打开runtime源码 -> 搜索objc_msgSend -> 找到objc-msg-arm64.s文件 -> 找到ENTRY _objc_msgSend
> 
> 汇编使用 ENTRY + 函数名字 函数入口
> 
> 使用 END_ENTRY + 函数名字 函数结束

* ***objc_class***

```
struct objc_class: objc_object {
    Class isa;
    Class superclass;
    cache_t cache;       
    class_data_bits_t bits; 
    .....	
}
```
> cache: 在数据结构的第三位，下面会用到

* ***cache_t***

```
struct cache_t {
    struct bucket_t *_buckets;
    mask_t _mask;
    mask_t _occupied;
    .....	
}
```
> _buckets: 是bucket_t结构体数组，bucket_t存放方法的SEL和IMP
> 
> _mask: 数组的大小-1，用于掩码，-1用于保证相与后不超过缓存大小
> 
> _occupied: 当前缓存的方法数

* ***bucket_t***

```
typedef unsigned long 	uintptr_t;
typedef uintptr_t 	cache_key_t;

struct bucket_t {
    cache_key_t _key;
    MethodCacheIMP _imp;
}

cache_key_t key = getKey(sel);

cache_key_t getKey(SEL sel) 
{
    assert(sel);
    return (cache_key_t)sel;
}
```
> _key: unsigned long类型，用来存放SEL的内存地址
> 
> _imp: 方法实现的IMP

* ***_objc_msgSend***
```
ENTRY _objc_msgSend

	UNWIND _objc_msgSend, NoFrame

	/** 
	 *  nil check and tagged pointer check
	 *
	 *  po与0作比较
	 */ 
	cmp	p0, #0
	
#if SUPPORT_TAGGED_POINTERS
	// less than or equal to)的意思当结果为小于等于的时候跳转执行
	b.le	LNilOrTagged		//  (MSB tagged pointer looks negative)
#else
	// 比较结果是等于（equal to），执行LReturnZero，否则不跳转
	b.eq	LReturnZero
#endif
	// 根据当前对象isa找到所属类
	ldr	p13, [x0]		// p13 = isa
	GetClassFromIsa_p16 p13, 1, x0	// p16 = class
LGetIsaDone:
	// calls imp or objc_msgSend_uncached
	CacheLookup NORMAL, _objc_msgSend, __objc_msgSend_uncached

#if SUPPORT_TAGGED_POINTERS
LNilOrTagged:
	b.eq	LReturnZero		// nil check
	GetTaggedClass
	b	LGetIsaDone
// SUPPORT_TAGGED_POINTERS
#endif

LReturnZero:
	// x0 is already zero
	mov	x1, #0
	movi	d0, #0
	movi	d1, #0
	movi	d2, #0
	movi	d3, #0
	ret
	
END_ENTRY _objc_msgSend
```
**_objc_msgSend 流程图**

```mermaid
graph TD

_objc_msgSend(_objc_msgSend)
cmp(`receiver`与0做比较,返回结果)
isSupportTaggedPointer(是否支持`tagged pointer`)
LNilOrTagged(跳转到`LNilOrTagged`)
cmpIsNil(`receiver`为空)
cmpIsNotNil(`receiver`不为空)
LReturnZero(直接返回)
GetTaggedClass(通过isa获取Class,GetClassFromIsa)
LGetIsaDone(跳转到`LGetIsaDone`,执行`CacheLookup`从缓存中查找)

cache_t(将class的首地址平移16个字节得到`cache_t`)
buckets(将`cache_t`的首地址与上&`0x0000ffffffffffff`得到`buckets`)
bucketIndex(SEL与上mask=`chche右移48`得到bucket的index)
bucket(`buckets`的首地址+偏移量=`index左移4位`取出`bucket`)
sel(判断取出bucket的sel与传入的sel是否相同)
selIsNil(判断从bucket中取出的sel是否为空)
cacheHit(缓存命中调用IMP)
MissLabelDynamic(MissLabelDynamic)
queryNextBucket(遍历向前查找bucket,每次按BUCKET_SIZE大小减少)
isQueryBucket(当前bucket地址是否小于buckets首地址)
__objc_msgSend_uncached(__objc_msgSend_uncached)
MethodTableLookup(在缓存中没有查找到sel,通过`MethodTableLookup`来进行查找)
lookUpImpOrForward(最终跳转到`lookUpImpOrForward`)

_objc_msgSend-->cmp-->isSupportTaggedPointer

isSupportTaggedPointer-->isSupport(是)
isSupportTaggedPointer-->isNotSupport(否)

isSupport-->b.le(`receiver`小于或者等于0)-->LNilOrTagged
isSupport-->`receiver`大于0-->GetTaggedClass

LNilOrTagged-->cmpIsNil-->LReturnZero
LNilOrTagged-->cmpIsNotNil-->GetTaggedClass-->LGetIsaDone

isNotSupport-->cmpIsNil
isNotSupport-->cmpIsNotNil

LGetIsaDone-->cache_t

cache_t-->cache_isNil(`cache_t`为空)-->buckets-->bucketIndex-->bucket-->sel
cache_t-->cache_isNotNil(`cache_t`不为空)-->LLookupPreopt\Function(跳转到`LLookupPreopt Function`)

sel-->Y1(是)-->cacheHit
sel-->N1(否)-->selIsNil

selIsNil-->Y2(是)-->MissLabelDynamic
selIsNil-->N2(否)-->queryNextBucket-->isQueryBucket

isQueryBucket-->Y3(是)-->__objc_msgSend_uncached-->MethodTableLookup-->lookUpImpOrForward
isQueryBucket-->N3(向前遍历查找)-->sel
```

**经过层层查找最终来到 lookUpImpOrForward**

```
x0 = receiver 
x1 = selector 
x2 = class 
x3 = LOOKUP_INITIALIZE | LOOKUP_RESOLVER
根据不同的behavior会执行不同的分支

IMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior) {
    const IMP forward_imp = (IMP)_objc_msgForward_impcache;
    IMP imp = nil;
    Class curClass;

    runtimeLock.assertUnlocked();

    // Optimistic cache lookup
    // 如果behavior标识符需要再查找缓存的话，重新查找一遍缓存
    if (fastpath(behavior & LOOKUP_CACHE)) {
        imp = cache_getImp(cls, sel);
        if (imp) goto done_nolock;
    }

    runtimeLock.lock();

    checkIsKnownClass(cls);

    if (slowpath(!cls->isRealized())) {
    	// 如果类还没有实现，需要进行实现，这是一个递归的方法，确保父类以及元类的继承关系。
        cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);
        // runtimeLock may have been dropped but is now locked again
    }

    if (slowpath((behavior & LOOKUP_INITIALIZE) && !cls->isInitialized())) {
    	// 如果没有初始化，需要初始化，会执行+initialize方法。
        cls = initializeAndLeaveLocked(cls, inst, runtimeLock);
    }

    runtimeLock.assertLocked();
    curClass = cls;

    for (unsigned attempts = unreasonableClassCount();;) {
        // curClass method list.
        // 在curClass中寻找方法，不在父类中寻找
        Method meth = getMethodNoSuper_nolock(curClass, sel);
        if (meth) {
            imp = meth->imp;
            goto done;
        }
	
        if (slowpath((curClass = curClass->superclass) == nil)) {
            // 如果curClass的父类为nil，还没找到，需要进行方法解析了
            // No implementation found, and method resolver didn't help.
            // Use forwarding.
            imp = forward_imp;
            break;
        }

        // Halt if there is a cycle in the superclass chain.
        // 如果父子类关系中有缓存在的话，attempts<0，发生异常
        if (slowpath(--attempts == 0)) {
            _objc_fatal("Memory corruption in class list.");
        }

        // Superclass cache.
        // 在父类缓存中查找缓存。
        imp = cache_getImp(curClass, sel);
        if (slowpath(imp == forward_imp)) {
            //如果父类中发现了forward的imp，停止查找，不进行缓存，先调用这个类的方法解析。
            break;
        }
        if (fastpath(imp)) {
            // 在父类中找到了方法实现，缓存到当前class即receiver对应的class中
            goto done;
        }
    }

    // No implementation found. Try method resolver once.
    (behavior = 11) & 10 = 10
    behavior = 11 ^ 10 = 01
    behavior = 01 & 10 = 0
    if (slowpath(behavior & LOOKUP_RESOLVER)) {
    	// 表示此处代码在本次流程中只会执行一次
        behavior ^= LOOKUP_RESOLVER;
        return resolveMethod_locked(inst, sel, cls, behavior);
    }

 done:
    // 存储sel以及imp到当前cls的缓存中去，此处衔接到cache_t的存储方法部分。
    log_and_fill_cache(cls, imp, sel, inst, curClass);
    runtimeLock.unlock();
 done_nolock:
    if (slowpath((behavior & LOOKUP_NIL) && imp == forward_imp)) {
    	// 如果当前behavior属于LOOKUP_NIL并且找到了forward_imp，返回空。
        return nil;
    }
    return imp;
}
```











